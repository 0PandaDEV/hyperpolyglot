static DISAMBIGUATIONS: phf::Map<&'static str, &'static [Rule]> =
::phf::Map {
    key: 732231254413039614,
    disps: ::phf::Slice::Static(&[
        (6, 72),
        (0, 1),
        (1, 0),
        (2, 2),
        (7, 45),
        (0, 11),
        (0, 54),
        (0, 79),
        (0, 48),
        (1, 41),
        (0, 3),
        (1, 13),
        (2, 50),
        (0, 2),
        (18, 68),
        (0, 6),
        (19, 66),
        (10, 5),
    ]),
    entries: ::phf::Slice::Static(&[
        (".1m", &[Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*Dd +(?:[^\"\\s]+|\"[^\"]+\")"),Pattern::Positive("^[.\'][ \\t]*Dt +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*Sh +(?:[^\"\\s]|\"[^\"]+\")"),]))},Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*TH +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*SH +(?:[^\"\\s]+|\"[^\"\\s]+)"),]))},Rule { language: "Roff", pattern: None},]),
        (".dsp", &[Rule { language: "Microsoft Developer Studio Project", pattern: Some(Pattern::Positive("# Microsoft Developer Studio Generated Build File"))},Rule { language: "Faust", pattern: Some(Pattern::Positive("\\bprocess\\s*[(=]|\\b(library|import)\\s*\\(\\s*\"|\\bdeclare\\s+(name|version|author|copyright|license)\\s+\""))},]),
        (".asy", &[Rule { language: "LTspice Symbol", pattern: Some(Pattern::Positive("^SymbolType[ \\t]"))},Rule { language: "Asymptote", pattern: None},]),
        (".nl", &[Rule { language: "NL", pattern: Some(Pattern::Positive("^(b|g)[0-9]+ "))},Rule { language: "NewLisp", pattern: None},]),
        (".5", &[Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*Dd +(?:[^\"\\s]+|\"[^\"]+\")"),Pattern::Positive("^[.\'][ \\t]*Dt +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*Sh +(?:[^\"\\s]|\"[^\"]+\")"),]))},Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*TH +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*SH +(?:[^\"\\s]+|\"[^\"\\s]+)"),]))},Rule { language: "Roff", pattern: None},]),
        (".pod", &[Rule { language: "Pod 6", pattern: Some(Pattern::Positive("^[\\s&&[^\\n]]*=(comment|begin pod|begin para|item\\d+)"))},Rule { language: "Pod", pattern: None},]),
        (".w", &[Rule { language: "OpenEdge ABL", pattern: Some(Pattern::Positive("&ANALYZE-SUSPEND _UIB-CODE-BLOCK _CUSTOM _DEFINITIONS"))},Rule { language: "CWeb", pattern: Some(Pattern::Positive("^@(<|\\w+\\.)"))},]),
        (".d", &[Rule { language: "D", pattern: Some(Pattern::Positive("^module\\s+[\\w.]*\\s*;|import\\s+[\\w\\s,.:]*;|\\w+\\s+\\w+\\s*\\(.*\\)(?:\\(.*\\))?\\s*{[^}]*}|unittest\\s*(?:\\(.*\\))?\\s*{[^}]*}"))},Rule { language: "DTrace", pattern: Some(Pattern::Positive("^(\\w+:\\w*:\\w*:\\w*|BEGIN|END|provider\\s+|(tick|profile)-\\w+\\s+{[^}]*}|#pragma\\s+D\\s+(option|attributes|depends_on)\\s|#pragma\\s+ident\\s)"))},Rule { language: "Makefile", pattern: Some(Pattern::Positive("([\\/\\\\].*:\\s+.*\\s\\\\$|: \\\\$|^[ %]:|^[\\w\\s\\/\\\\.]+\\w+\\.\\w+\\s*:\\s+[\\w\\s\\/\\\\.]+\\w+\\.\\w+)"))},]),
        (".ecl", &[Rule { language: "ECLiPSe", pattern: Some(Pattern::Positive("^[^#]+:-"))},Rule { language: "ECL", pattern: Some(Pattern::Positive(":="))},]),
        (".cl", &[Rule { language: "Common Lisp", pattern: Some(Pattern::Positive("^\\s*\\((?i:defun|in-package|defpackage) "))},Rule { language: "Cool", pattern: Some(Pattern::Positive("^class"))},Rule { language: "OpenCL", pattern: Some(Pattern::Positive("\\/\\* |\\/\\/ |^\\}"))},]),
        (".md", &[Rule { language: "Markdown", pattern: Some(Pattern::Or(&[Pattern::Positive("(^[-A-Za-z0-9=#!\\*\\[|>])|<\\/"),Pattern::Positive("\\A\\z"),]))},Rule { language: "GCC Machine Description", pattern: Some(Pattern::Positive("^(;;|\\(define_)"))},Rule { language: "Markdown", pattern: None},]),
        (".rno", &[Rule { language: "RUNOFF", pattern: Some(Pattern::Positive("(?i:^\\.!|^\\f|\\f$|^\\.end lit(?:eral)?\\b|^\\.[a-zA-Z].*?;\\.[a-zA-Z](?:[; \\t])|\\^\\*[^\\s*][^*]*\\\\\\*(?=$|\\s)|^\\.c;[ \\t]*\\w+)"))},Rule { language: "Roff", pattern: Some(Pattern::Positive("^\\.\\\\\" "))},]),
        (".r", &[Rule { language: "Rebol", pattern: Some(Pattern::Positive("(?i:\\bRebol\\b)"))},Rule { language: "R", pattern: Some(Pattern::Positive("<-|^\\s*#"))},]),
        (".tsx", &[Rule { language: "TSX", pattern: Some(Pattern::Positive("^\\s*(import.+(from\\s+|require\\()[\'\"]react|\\/\\/\\/\\s*<reference\\s)"))},Rule { language: "XML", pattern: Some(Pattern::Positive("(?i:^\\s*<\\?xml\\s+version)"))},]),
        (".gml", &[Rule { language: "XML", pattern: Some(Pattern::Positive("(?i:^\\s*(\\<\\?xml|xmlns))"))},Rule { language: "Graph Modeling Language", pattern: Some(Pattern::Positive("(?i:^\\s*(graph|node)\\s+\\[$)"))},Rule { language: "Gerber Image", pattern: Some(Pattern::Positive("\\*\\%$"))},Rule { language: "Game Maker Language", pattern: None},]),
        (".3in", &[Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*Dd +(?:[^\"\\s]+|\"[^\"]+\")"),Pattern::Positive("^[.\'][ \\t]*Dt +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*Sh +(?:[^\"\\s]|\"[^\"]+\")"),]))},Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*TH +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*SH +(?:[^\"\\s]+|\"[^\"\\s]+)"),]))},Rule { language: "Roff", pattern: None},]),
        (".pp", &[Rule { language: "Pascal", pattern: Some(Pattern::Positive("^\\s*end[.;]"))},Rule { language: "Puppet", pattern: Some(Pattern::Positive("^\\s+\\w+\\s+=>\\s"))},]),
        (".properties", &[Rule { language: "INI", pattern: Some(Pattern::And(&[Pattern::Positive("^[^#!;][^=]*="),Pattern::Positive("^[;\\[]"),]))},Rule { language: "Java Properties", pattern: Some(Pattern::And(&[Pattern::Positive("^[^#!;][^=]*="),Pattern::Positive("^[#!]"),]))},Rule { language: "INI", pattern: Some(Pattern::Positive("^[^#!;][^=]*="))},Rule { language: "Java properties", pattern: Some(Pattern::Positive("^[^#!][^:]*:"))},]),
        (".q", &[Rule { language: "q", pattern: Some(Pattern::Positive("((?i:[A-Z.][\\w.]*:{)|(^|\\n)\\\\(cd?|d|l|p|ts?) )"))},Rule { language: "HiveQL", pattern: Some(Pattern::Positive("(?i:SELECT\\s+[\\w*,]+\\s+FROM|(CREATE|ALTER|DROP)\\s(DATABASE|SCHEMA|TABLE))"))},]),
        (".srt", &[Rule { language: "SubRip Text", pattern: Some(Pattern::Positive("^(\\d{2}:\\d{2}:\\d{2},\\d{3})\\s*(-->)\\s*(\\d{2}:\\d{2}:\\d{2},\\d{3})$"))},]),
        (".3p", &[Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*Dd +(?:[^\"\\s]+|\"[^\"]+\")"),Pattern::Positive("^[.\'][ \\t]*Dt +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*Sh +(?:[^\"\\s]|\"[^\"]+\")"),]))},Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*TH +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*SH +(?:[^\"\\s]+|\"[^\"\\s]+)"),]))},Rule { language: "Roff", pattern: None},]),
        (".mdoc", &[Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*Dd +(?:[^\"\\s]+|\"[^\"]+\")"),Pattern::Positive("^[.\'][ \\t]*Dt +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*Sh +(?:[^\"\\s]|\"[^\"]+\")"),]))},Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*TH +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*SH +(?:[^\"\\s]+|\"[^\"\\s]+)"),]))},Rule { language: "Roff", pattern: None},]),
        (".2", &[Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*Dd +(?:[^\"\\s]+|\"[^\"]+\")"),Pattern::Positive("^[.\'][ \\t]*Dt +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*Sh +(?:[^\"\\s]|\"[^\"]+\")"),]))},Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*TH +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*SH +(?:[^\"\\s]+|\"[^\"\\s]+)"),]))},Rule { language: "Roff", pattern: None},]),
        (".1x", &[Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*Dd +(?:[^\"\\s]+|\"[^\"]+\")"),Pattern::Positive("^[.\'][ \\t]*Dt +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*Sh +(?:[^\"\\s]|\"[^\"]+\")"),]))},Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*TH +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*SH +(?:[^\"\\s]+|\"[^\"\\s]+)"),]))},Rule { language: "Roff", pattern: None},]),
        (".lsp", &[Rule { language: "Common Lisp", pattern: Some(Pattern::Positive("^\\s*\\((?i:defun|in-package|defpackage) "))},Rule { language: "NewLisp", pattern: Some(Pattern::Positive("^\\s*\\(define "))},]),
        (".tst", &[Rule { language: "GAP", pattern: Some(Pattern::Positive("gap> "))},Rule { language: "Scilab", pattern: None},]),
        (".ms", &[Rule { language: "Roff", pattern: Some(Pattern::Positive("^[.\'][A-Za-z]{2}(\\s|$)"))},Rule { language: "Unix Assembly", pattern: Some(Pattern::And(&[Pattern::Negative("/\\*"),Pattern::Positive("^\\s*\\.(?:include\\s|globa?l\\s|[A-Za-z][_A-Za-z0-9]*:)"),]))},Rule { language: "MAXScript", pattern: None},]),
        (".3pm", &[Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*Dd +(?:[^\"\\s]+|\"[^\"]+\")"),Pattern::Positive("^[.\'][ \\t]*Dt +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*Sh +(?:[^\"\\s]|\"[^\"]+\")"),]))},Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*TH +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*SH +(?:[^\"\\s]+|\"[^\"\\s]+)"),]))},Rule { language: "Roff", pattern: None},]),
        (".asc", &[Rule { language: "Public Key", pattern: Some(Pattern::Positive("^(----[- ]BEGIN|ssh-(rsa|dss)) "))},Rule { language: "AsciiDoc", pattern: Some(Pattern::Positive("^[=-]+(\\s|\\n)|{{[A-Za-z]"))},Rule { language: "AGS Script", pattern: Some(Pattern::Positive("^(\\/\\/.+|((import|export)\\s+)?(function|int|float|char)\\s+((room|repeatedly|on|game)_)?([A-Za-z]+[A-Za-z_0-9]+)\\s*[;\\(])"))},]),
        (".cls", &[Rule { language: "TeX", pattern: Some(Pattern::Positive("\\\\\\w+{"))},Rule { language: "ObjectScript", pattern: Some(Pattern::Positive("^Class\\s"))},]),
        (".es", &[Rule { language: "Erlang", pattern: Some(Pattern::Positive("^\\s*(?:%%|main\\s*\\(.*?\\)\\s*->)"))},Rule { language: "JavaScript", pattern: Some(Pattern::Positive("(?m:\\/\\/|(\"|\')use strict\\1|export\\s+default\\s|\\/\\*.*?\\*\\/)"))},]),
        (".rs", &[Rule { language: "Rust", pattern: Some(Pattern::Positive("^(use |fn |mod |pub |macro_rules|impl|#!?\\[)"))},Rule { language: "RenderScript", pattern: Some(Pattern::Positive("#include|#pragma\\s+(rs|version)|__attribute__"))},]),
        (".l", &[Rule { language: "Common Lisp", pattern: Some(Pattern::Positive("\\(def(un|macro)\\s"))},Rule { language: "Lex", pattern: Some(Pattern::Positive("^(%[%{}]xs|<.*>)"))},Rule { language: "Roff", pattern: Some(Pattern::Positive("^\\.[A-Za-z]{2}(\\s|$)"))},Rule { language: "PicoLisp", pattern: Some(Pattern::Positive("^\\((de|class|rel|code|data|must)\\s"))},]),
        (".p", &[Rule { language: "Gnuplot", pattern: Some(Pattern::Or(&[Pattern::Positive("^s?plot\\b"),Pattern::Positive("^set\\s+(term|terminal|out|output|[xy]tics|[xy]label|[xy]range|style)\\b"),]))},Rule { language: "OpenEdge ABL", pattern: None},]),
        (".1in", &[Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*Dd +(?:[^\"\\s]+|\"[^\"]+\")"),Pattern::Positive("^[.\'][ \\t]*Dt +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*Sh +(?:[^\"\\s]|\"[^\"]+\")"),]))},Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*TH +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*SH +(?:[^\"\\s]+|\"[^\"\\s]+)"),]))},Rule { language: "Roff", pattern: None},]),
        (".plist", &[Rule { language: "XML Property List", pattern: Some(Pattern::Positive("<!DOCTYPE\\s+plist"))},Rule { language: "OpenStep Property List", pattern: None},]),
        (".3", &[Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*Dd +(?:[^\"\\s]+|\"[^\"]+\")"),Pattern::Positive("^[.\'][ \\t]*Dt +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*Sh +(?:[^\"\\s]|\"[^\"]+\")"),]))},Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*TH +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*SH +(?:[^\"\\s]+|\"[^\"\\s]+)"),]))},Rule { language: "Roff", pattern: None},]),
        (".v", &[Rule { language: "Coq", pattern: Some(Pattern::Positive("\\(\\*.*?\\*\\)|(?:^|\\s)(?:Proof|Qed)\\.(?:$|\\s)|(?:^|\\s)Require[ \\t]+Import\\s"))},Rule { language: "Verilog", pattern: Some(Pattern::Positive("^[ \\t]*module\\s+[^\\s()]+\\s+\\#?\\(|^[ \\t]*`(?:ifdef|timescale)\\s|^[ \\t]*always[ \\t]+@"))},Rule { language: "V", pattern: Some(Pattern::Positive("\\$(?:if|else)[ \\t]|^[ \\t]*fn\\s+[^\\s()]+\\(.*?\\).*?\\{|^[ \\t]*for\\s*\\{"))},]),
        (".props", &[Rule { language: "XML", pattern: Some(Pattern::Positive("^(\\s*)(?i:<Project|<Import|<Property|<\\?xml|xmlns)"))},Rule { language: "INI", pattern: Some(Pattern::Positive("(?i:\\w+\\s*=\\s*)"))},]),
        (".7", &[Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*Dd +(?:[^\"\\s]+|\"[^\"]+\")"),Pattern::Positive("^[.\'][ \\t]*Dt +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*Sh +(?:[^\"\\s]|\"[^\"]+\")"),]))},Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*TH +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*SH +(?:[^\"\\s]+|\"[^\"\\s]+)"),]))},Rule { language: "Roff", pattern: None},]),
        (".asm", &[Rule { language: "Motorola 68K Assembly", pattern: Some(Pattern::Or(&[Pattern::Positive("(?im)\\bmoveq(?:\\.l)?\\s+#(?:\\$-?[0-9a-f]{1,3}|%[0-1]{1,8}|-?[0-9]{1,3}),\\s*d[0-7]\\b"),Pattern::Positive("(?im)^\\s*move(?:\\.[bwl])?\\s+(?:sr|usp),\\s*[^\\s]+"),Pattern::Positive("(?im)^\\s*move\\.[bwl]\\s+.*\\b[ad]\\d"),Pattern::Positive("(?im)^\\s*movem\\.[bwl]\\b"),Pattern::Positive("(?im)^\\s*move[mp](?:\\.[wl])?\\b"),Pattern::Positive("(?im)^\\s*btst\\b"),Pattern::Positive("(?im)^\\s*dbra\\b"),]))},]),
        (".s", &[Rule { language: "Motorola 68K Assembly", pattern: Some(Pattern::Or(&[Pattern::Positive("(?im)\\bmoveq(?:\\.l)?\\s+#(?:\\$-?[0-9a-f]{1,3}|%[0-1]{1,8}|-?[0-9]{1,3}),\\s*d[0-7]\\b"),Pattern::Positive("(?im)^\\s*move(?:\\.[bwl])?\\s+(?:sr|usp),\\s*[^\\s]+"),Pattern::Positive("(?im)^\\s*move\\.[bwl]\\s+.*\\b[ad]\\d"),Pattern::Positive("(?im)^\\s*movem\\.[bwl]\\b"),Pattern::Positive("(?im)^\\s*move[mp](?:\\.[wl])?\\b"),Pattern::Positive("(?im)^\\s*btst\\b"),Pattern::Positive("(?im)^\\s*dbra\\b"),]))},]),
        (".1", &[Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*Dd +(?:[^\"\\s]+|\"[^\"]+\")"),Pattern::Positive("^[.\'][ \\t]*Dt +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*Sh +(?:[^\"\\s]|\"[^\"]+\")"),]))},Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*TH +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*SH +(?:[^\"\\s]+|\"[^\"\\s]+)"),]))},Rule { language: "Roff", pattern: None},]),
        (".ncl", &[Rule { language: "XML", pattern: Some(Pattern::Positive("^\\s*<\\?xml\\s+version"))},Rule { language: "Text", pattern: Some(Pattern::Positive("THE_TITLE"))},]),
        (".bb", &[Rule { language: "BlitzBasic", pattern: Some(Pattern::Positive("(<^\\s*; |End Function)"))},Rule { language: "BitBake", pattern: Some(Pattern::Positive("^\\s*(# |include|require)\\b"))},]),
        (".odin", &[Rule { language: "Object Data Instance Notation", pattern: Some(Pattern::Positive("(?:^|<)\\s*[A-Za-z0-9_]+\\s*=\\s*<"))},Rule { language: "Odin", pattern: Some(Pattern::Positive("package\\s+\\w+|\\b(?:im|ex)port\\s*\"[\\w:./]+\"|\\w+\\s*::\\s*(?:proc|struct)\\s*\\(|^\\s*//\\s"))},]),
        (".lisp", &[Rule { language: "Common Lisp", pattern: Some(Pattern::Positive("^\\s*\\((?i:defun|in-package|defpackage) "))},Rule { language: "NewLisp", pattern: Some(Pattern::Positive("^\\s*\\(define "))},]),
        (".6", &[Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*Dd +(?:[^\"\\s]+|\"[^\"]+\")"),Pattern::Positive("^[.\'][ \\t]*Dt +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*Sh +(?:[^\"\\s]|\"[^\"]+\")"),]))},Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*TH +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*SH +(?:[^\"\\s]+|\"[^\"\\s]+)"),]))},Rule { language: "Roff", pattern: None},]),
        (".f", &[Rule { language: "Forth", pattern: Some(Pattern::Positive("^: "))},Rule { language: "Filebench WML", pattern: Some(Pattern::Positive("flowop"))},Rule { language: "Fortran", pattern: Some(Pattern::Positive("^(?i:[c*][^abd-z]|      (subroutine|program|end|data)\\s|\\s*!)"))},]),
        (".cs", &[Rule { language: "Smalltalk", pattern: Some(Pattern::Positive("![\\w\\s]+methodsFor: "))},Rule { language: "C#", pattern: Some(Pattern::Positive("^(\\s*namespace\\s*[\\w\\.]+\\s*{|\\s*\\/\\/)"))},]),
        (".h", &[Rule { language: "Objective-C", pattern: Some(Pattern::Positive("^\\s*(@(interface|class|protocol|property|end|synchronised|selector|implementation)\\b|#import\\s+.+\\.h[\">])"))},Rule { language: "C++", pattern: Some(Pattern::Or(&[Pattern::Positive("^\\s*#\\s*include <(cstdint|string|vector|map|list|array|bitset|queue|stack|forward_list|unordered_map|unordered_set|(i|o|io)stream)>"),Pattern::Positive("^\\s*template\\s*<"),Pattern::Positive("^[ \\t]*(try|constexpr)"),Pattern::Positive("^[ \\t]*catch\\s*\\("),Pattern::Positive("^[ \\t]*(class|(using[ \\t]+)?namespace)\\s+\\w+"),Pattern::Positive("^[ \\t]*(private|public|protected):$"),Pattern::Positive("std::\\w+"),]))},]),
        (".3m", &[Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*Dd +(?:[^\"\\s]+|\"[^\"]+\")"),Pattern::Positive("^[.\'][ \\t]*Dt +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*Sh +(?:[^\"\\s]|\"[^\"]+\")"),]))},Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*TH +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*SH +(?:[^\"\\s]+|\"[^\"\\s]+)"),]))},Rule { language: "Roff", pattern: None},]),
        (".8", &[Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*Dd +(?:[^\"\\s]+|\"[^\"]+\")"),Pattern::Positive("^[.\'][ \\t]*Dt +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*Sh +(?:[^\"\\s]|\"[^\"]+\")"),]))},Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*TH +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*SH +(?:[^\"\\s]+|\"[^\"\\s]+)"),]))},Rule { language: "Roff", pattern: None},]),
        (".rpy", &[Rule { language: "Python", pattern: Some(Pattern::Positive("(?m:^(import|from|class|def)\\s)"))},Rule { language: "Ren'Py", pattern: None},]),
        (".yy", &[Rule { language: "JSON", pattern: Some(Pattern::Positive("\\\"modelName\\\"\\:\\s*\\\"GM"))},Rule { language: "Yacc", pattern: None},]),
        (".toc", &[Rule { language: "World of Warcraft Addon Data", pattern: Some(Pattern::Positive("^## |@no-lib-strip@"))},Rule { language: "TeX", pattern: Some(Pattern::Positive("^\\\\(contentsline|defcounter|beamer|boolfalse)"))},]),
        (".hh", &[Rule { language: "Hack", pattern: Some(Pattern::Positive("<\\?hh"))},]),
        (".mod", &[Rule { language: "XML", pattern: Some(Pattern::Positive("<!ENTITY "))},Rule { language: "Modula-2", pattern: Some(Pattern::Positive("^\\s*(?i:MODULE|END) [\\w\\.]+;"))},Rule { language: "Linux Kernel Module", pattern: None},]),
        (".vba", &[Rule { language: "Vim script", pattern: Some(Pattern::Positive("^UseVimball"))},Rule { language: "VBA", pattern: None},]),
        (".for", &[Rule { language: "Forth", pattern: Some(Pattern::Positive("^: "))},Rule { language: "Fortran", pattern: Some(Pattern::Positive("^(?i:[c*][^abd-z]|      (subroutine|program|end|data)\\s|\\s*!)"))},]),
        (".gd", &[Rule { language: "GAP", pattern: Some(Pattern::Positive("\\s*(Declare|BindGlobal|KeyDependentOperation)"))},Rule { language: "GDScript", pattern: Some(Pattern::Positive("\\s*(extends|var|const|enum|func|class|signal|tool|yield|assert|onready)"))},]),
        (".builds", &[Rule { language: "XML", pattern: Some(Pattern::Positive("^(\\s*)(?i:<Project|<Import|<Property|<?xml|xmlns)"))},Rule { language: "Text", pattern: None},]),
        (".3x", &[Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*Dd +(?:[^\"\\s]+|\"[^\"]+\")"),Pattern::Positive("^[.\'][ \\t]*Dt +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*Sh +(?:[^\"\\s]|\"[^\"]+\")"),]))},Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*TH +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*SH +(?:[^\"\\s]+|\"[^\"\\s]+)"),]))},Rule { language: "Roff", pattern: None},]),
        (".x", &[Rule { language: "DirectX 3D File", pattern: Some(Pattern::Positive("^xof 030(2|3)(?:txt|bin|tzip|bzip)\\b"))},Rule { language: "RPC", pattern: Some(Pattern::Positive("\\b(program|version)\\s+\\w+\\s*{|\\bunion\\s+\\w+\\s+switch\\s*\\("))},Rule { language: "Logos", pattern: Some(Pattern::Positive("^%(end|ctor|hook|group)\\b"))},Rule { language: "Linker Script", pattern: Some(Pattern::Positive("OUTPUT_ARCH\\(|OUTPUT_FORMAT\\(|SECTIONS"))},]),
        (".as", &[Rule { language: "ActionScript", pattern: Some(Pattern::Positive("^\\s*(package\\s+[a-z0-9_\\.]+|import\\s+[a-zA-Z0-9_\\.]+;|class\\s+[A-Za-z0-9_]+\\s+extends\\s+[A-Za-z0-9_]+)"))},Rule { language: "AngelScript", pattern: None},]),
        (".3qt", &[Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*Dd +(?:[^\"\\s]+|\"[^\"]+\")"),Pattern::Positive("^[.\'][ \\t]*Dt +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*Sh +(?:[^\"\\s]|\"[^\"]+\")"),]))},Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*TH +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*SH +(?:[^\"\\s]+|\"[^\"\\s]+)"),]))},Rule { language: "Roff", pattern: None},]),
        (".t", &[Rule { language: "Perl", pattern: Some(Pattern::Positive("\\buse\\s+(?:strict\\b|v?5\\.)"))},Rule { language: "Raku", pattern: Some(Pattern::Positive("^\\s*(?:use\\s+v6\\b|\\bmodule\\b|\\b(?:my\\s+)?class\\b)"))},Rule { language: "Turing", pattern: Some(Pattern::Positive("^\\s*%[ \\t]+|^\\s*var\\s+\\w+(\\s*:\\s*\\w+)?\\s*:=\\s*\\w+"))},]),
        (".ml", &[Rule { language: "OCaml", pattern: Some(Pattern::Positive("(^\\s*module)|let rec |match\\s+(\\S+\\s)+with"))},Rule { language: "Standard ML", pattern: Some(Pattern::Positive("=> |case\\s+(\\S+\\s)+of"))},]),
        (".pl", &[Rule { language: "Prolog", pattern: Some(Pattern::Positive("^[^#]*:-"))},Rule { language: "Perl", pattern: Some(Pattern::Positive("\\buse\\s+(?:strict\\b|v?5\\.)"))},Rule { language: "Raku", pattern: Some(Pattern::Positive("^\\s*(?:use\\s+v6\\b|\\bmodule\\b|\\b(?:my\\s+)?class\\b)"))},]),
        (".pm", &[Rule { language: "Perl", pattern: Some(Pattern::Positive("\\buse\\s+(?:strict\\b|v?5\\.)"))},Rule { language: "Raku", pattern: Some(Pattern::Positive("^\\s*(?:use\\s+v6\\b|\\bmodule\\b|\\b(?:my\\s+)?class\\b)"))},Rule { language: "X PixMap", pattern: Some(Pattern::Positive("^\\s*\\/\\* XPM \\*\\/"))},]),
        (".sc", &[Rule { language: "SuperCollider", pattern: Some(Pattern::Positive("(?i:\\^(this|super)\\.|^\\s*~\\w+\\s*=\\.)"))},Rule { language: "Scala", pattern: Some(Pattern::Positive("(^\\s*import (scala|java)\\.|^\\s*class\\b)"))},]),
        (".fs", &[Rule { language: "Forth", pattern: Some(Pattern::Positive("^(: |new-device)"))},Rule { language: "F#", pattern: Some(Pattern::Positive("^\\s*(#light|import|let|module|namespace|open|type)"))},Rule { language: "GLSL", pattern: Some(Pattern::Positive("^\\s*(#version|precision|uniform|varying|vec[234])"))},Rule { language: "Filterscript", pattern: Some(Pattern::Positive("#include|#pragma\\s+(rs|version)|__attribute__"))},]),
        (".ls", &[Rule { language: "LoomScript", pattern: Some(Pattern::Positive("^\\s*package\\s*[\\w\\.\\/\\*\\s]*\\s*{"))},Rule { language: "LiveScript", pattern: None},]),
        (".php", &[Rule { language: "Hack", pattern: Some(Pattern::Positive("<\\?hh"))},Rule { language: "PHP", pattern: Some(Pattern::Positive("<\\?[^h]"))},]),
        (".m", &[Rule { language: "Objective-C", pattern: Some(Pattern::Positive("^\\s*(@(interface|class|protocol|property|end|synchronised|selector|implementation)\\b|#import\\s+.+\\.h[\">])"))},Rule { language: "Mercury", pattern: Some(Pattern::Positive(":- module"))},Rule { language: "MUF", pattern: Some(Pattern::Positive("^: "))},Rule { language: "M", pattern: Some(Pattern::Positive("^\\s*;"))},Rule { language: "Mathematica", pattern: Some(Pattern::And(&[Pattern::Positive("\\(\\*"),Pattern::Positive("\\*\\)$"),]))},Rule { language: "MATLAB", pattern: Some(Pattern::Positive("^\\s*%"))},Rule { language: "Limbo", pattern: Some(Pattern::Positive("^\\w+\\s*:\\s*module\\s*{"))},]),
        (".sql", &[Rule { language: "PLpgSQL", pattern: Some(Pattern::Positive("(?i:^\\\\i\\b|AS \\$\\$|LANGUAGE \'?plpgsql\'?|SECURITY (DEFINER|INVOKER)|BEGIN( WORK )?;)"))},Rule { language: "SQLPL", pattern: Some(Pattern::Positive("(?i:(alter module)|(language sql)|(begin( NOT)+ atomic)|signal SQLSTATE \'[0-9]+\')"))},Rule { language: "PLSQL", pattern: Some(Pattern::Positive("(?i:\\$\\$PLSQL_|XMLTYPE|sysdate|systimestamp|\\.nextval|connect by|AUTHID (DEFINER|CURRENT_USER)|constructor\\W+function)"))},Rule { language: "TSQL", pattern: Some(Pattern::And(&[Pattern::Negative("(?i:IDENTIFIED|NUMBER|VARCHAR2|REPEAT|UNTIL|IMMEDIATE)"),Pattern::Positive("(?i:(GO)|(@@)|(CREATE PROCEDURE)|BEGIN( TRY| CATCH)|OUTPUT( INSERTED)|IF|ELSE|IIF|CHOOSE|CURSOR|FETCH|DEALLOCATE|DECLARE)"),]))},Rule { language: "SQL", pattern: Some(Pattern::Negative("(?i:begin|boolean|package|exception)"))},]),
        (".mask", &[Rule { language: "Unity3d Asset", pattern: Some(Pattern::Positive("tag:unity3d.com"))},]),
        (".4", &[Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*Dd +(?:[^\"\\s]+|\"[^\"]+\")"),Pattern::Positive("^[.\'][ \\t]*Dt +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*Sh +(?:[^\"\\s]|\"[^\"]+\")"),]))},Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*TH +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*SH +(?:[^\"\\s]+|\"[^\"\\s]+)"),]))},Rule { language: "Roff", pattern: None},]),
        (".inc", &[Rule { language: "Motorola 68K Assembly", pattern: Some(Pattern::Or(&[Pattern::Positive("(?im)\\bmoveq(?:\\.l)?\\s+#(?:\\$-?[0-9a-f]{1,3}|%[0-1]{1,8}|-?[0-9]{1,3}),\\s*d[0-7]\\b"),Pattern::Positive("(?im)^\\s*move(?:\\.[bwl])?\\s+(?:sr|usp),\\s*[^\\s]+"),Pattern::Positive("(?im)^\\s*move\\.[bwl]\\s+.*\\b[ad]\\d"),Pattern::Positive("(?im)^\\s*movem\\.[bwl]\\b"),Pattern::Positive("(?im)^\\s*move[mp](?:\\.[wl])?\\b"),Pattern::Positive("(?im)^\\s*btst\\b"),Pattern::Positive("(?im)^\\s*dbra\\b"),]))},Rule { language: "PHP", pattern: Some(Pattern::Positive("^<\\?(?:php)?"))},Rule { language: "SourcePawn", pattern: Some(Pattern::Positive("^public\\s+(?:SharedPlugin(?:\\s+|:)__pl_\\w+\\s*=(?:\\s*{)?|(?:void\\s+)?__pl_\\w+_SetNTVOptional\\(\\)(?:\\s*{)?)"))},Rule { language: "NASL", pattern: Some(Pattern::Or(&[Pattern::Positive("^\\s*include\\s*\\(\\s*(?:\"|\')[\\\\/\\w\\-\\.:\\s]+\\.(?:nasl|inc)\\s*(?:\"|\')\\s*\\)\\s*;"),Pattern::Positive("^\\s*(?:global|local)_var\\s+(?:\\w+(?:\\s*=\\s*[\\w\\-\"\']+)?\\s*)(?:,\\s*\\w+(?:\\s*=\\s*[\\w\\-\"\']+)?\\s*)*+\\s*;"),Pattern::Positive("^\\s*namespace\\s+\\w+\\s*{"),Pattern::Positive("^\\s*object\\s+\\w+\\s*(?:extends\\s+\\w+(?:::\\w+)?)?\\s*{"),Pattern::Positive("^\\s*(?:public\\s+|private\\s+|\\s*)function\\s+\\w+\\s*\\([\\w\\s,]*\\)\\s*{"),]))},Rule { language: "POV-Ray SDL", pattern: Some(Pattern::Positive("^\\s*#(declare|local|macro|while)\\s"))},]),
        (".man", &[Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*Dd +(?:[^\"\\s]+|\"[^\"]+\")"),Pattern::Positive("^[.\'][ \\t]*Dt +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*Sh +(?:[^\"\\s]|\"[^\"]+\")"),]))},Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*TH +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*SH +(?:[^\"\\s]+|\"[^\"\\s]+)"),]))},Rule { language: "Roff", pattern: None},]),
        (".9", &[Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*Dd +(?:[^\"\\s]+|\"[^\"]+\")"),Pattern::Positive("^[.\'][ \\t]*Dt +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*Sh +(?:[^\"\\s]|\"[^\"]+\")"),]))},Rule { language: "Roff Manpage", pattern: Some(Pattern::And(&[Pattern::Positive("^[.\'][ \\t]*TH +(?:[^\"\\s]+|\"[^\"]+\") +\"?(?:[1-9]|@[^\\s@]+@)"),Pattern::Positive("^[.\'][ \\t]*SH +(?:[^\"\\s]+|\"[^\"\\s]+)"),]))},Rule { language: "Roff", pattern: None},]),
        (".n", &[Rule { language: "Roff", pattern: Some(Pattern::Positive("^[.\']"))},Rule { language: "Nemerle", pattern: Some(Pattern::Positive("^(module|namespace|using)\\s"))},]),
        (".pro", &[Rule { language: "Proguard", pattern: Some(Pattern::Positive("^-(include\\b.*\\.pro$|keep\\b|keepclassmembers\\b|keepattributes\\b)"))},Rule { language: "Prolog", pattern: Some(Pattern::Positive("^[^\\[#]+:-"))},Rule { language: "INI", pattern: Some(Pattern::Positive("last_client="))},Rule { language: "QMake", pattern: Some(Pattern::And(&[Pattern::Positive("HEADERS"),Pattern::Positive("SOURCES"),]))},Rule { language: "IDL", pattern: Some(Pattern::Positive("^\\s*function[ \\w,]+$"))},]),
        (".i", &[Rule { language: "Motorola 68K Assembly", pattern: Some(Pattern::Or(&[Pattern::Positive("(?im)\\bmoveq(?:\\.l)?\\s+#(?:\\$-?[0-9a-f]{1,3}|%[0-1]{1,8}|-?[0-9]{1,3}),\\s*d[0-7]\\b"),Pattern::Positive("(?im)^\\s*move(?:\\.[bwl])?\\s+(?:sr|usp),\\s*[^\\s]+"),Pattern::Positive("(?im)^\\s*move\\.[bwl]\\s+.*\\b[ad]\\d"),Pattern::Positive("(?im)^\\s*movem\\.[bwl]\\b"),Pattern::Positive("(?im)^\\s*move[mp](?:\\.[wl])?\\b"),Pattern::Positive("(?im)^\\s*btst\\b"),Pattern::Positive("(?im)^\\s*dbra\\b"),]))},Rule { language: "SWIG", pattern: Some(Pattern::Positive("^[ \\t]*%[a-z_]+\\b|^%[{}]$"))},]),
        (".fr", &[Rule { language: "Forth", pattern: Some(Pattern::Positive("^(: |also |new-device|previous )"))},Rule { language: "Frege", pattern: Some(Pattern::Positive("^\\s*(import|module|package|data|type) "))},Rule { language: "Text", pattern: None},]),
        (".gs", &[Rule { language: "GLSL", pattern: Some(Pattern::Positive("^#version\\s+[0-9]+\\b"))},Rule { language: "Gosu", pattern: Some(Pattern::Positive("^uses java\\."))},]),
        (".ts", &[Rule { language: "XML", pattern: Some(Pattern::Positive("<TS\\b"))},Rule { language: "TypeScript", pattern: None},]),
        (".ch", &[Rule { language: "xBase", pattern: Some(Pattern::Positive("^\\s*#\\s*(?i:if|ifdef|ifndef|define|command|xcommand|translate|xtranslate|include|pragma|undef)\\b"))},]),
        (".ice", &[Rule { language: "JSON", pattern: Some(Pattern::Positive("\\A\\s*[{\\[]"))},Rule { language: "Slice", pattern: None},]),
    ]),
};

